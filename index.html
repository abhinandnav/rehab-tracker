<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rehabilitation Exercise Game</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #111;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
    }
    #canvas {
      border: 2px solid #fff;
      background: #222;
    }
    #controls {
      margin-top: 15px;
    }
    button {
      margin: 0 5px;
      padding: 8px 15px;
      border: none;
      border-radius: 6px;
      background: #4caf50;
      color: white;
      font-size: 16px;
      cursor: pointer;
    }
    button:hover {
      background: #45a049;
    }
    #status {
      margin-top: 10px;
      font-size: 14px;
      color: #ccc;
    }
  </style>
</head>
<body>
  <h1>Rehabilitation Exercise Game</h1>
  <video id="webcam" width="300" height="200" autoplay muted playsinline style="display:none;"></video>
  <canvas id="canvas" width="400" height="400"></canvas>

  <div id="controls">
    <button id="btnStart">Start</button>
    <button id="btnContinue" style="display:none;">Continue</button>
    <button id="btnPause" style="display:none;">Pause</button>
    <button id="btnRestart" style="display:none;">Restart</button>
  </div>
  <div id="status">Press Start to begin</div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
  <script>
    const MODEL_URL = "https://teachablemachine.withgoogle.com/models/ZwgUkHwE_/";

    const webcamElement = document.getElementById("webcam");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const btnStart = document.getElementById("btnStart");
    const btnContinue = document.getElementById("btnContinue");
    const btnPause = document.getElementById("btnPause");
    const btnRestart = document.getElementById("btnRestart");
    const statusText = document.getElementById("status");

    let model, webcamStream;
    let gameState = "idle";
    let currentClass = 1;
    let ball, paddle, blocks = [];

    function setStatus(text) {
      statusText.textContent = text;
    }

    async function loadModel() {
      setStatus("Loading model...");
      model = await tmImage.load(MODEL_URL + "model.json", MODEL_URL + "metadata.json");
      setStatus("Model loaded!");
    }

    async function startWebcam() {
      webcamStream = await navigator.mediaDevices.getUserMedia({ video: true });
      webcamElement.srcObject = webcamStream;
      return new Promise(resolve => webcamElement.onloadedmetadata = () => resolve());
    }

    function initGame1() {
      ball = { x: 200, y: 200, radius: 15, dx: 2, dy: 2 };
      paddle = { x: 170, y: 370, width: 60, height: 10 };
    }

    function initGame2() {
      blocks = [];
      for (let i = 0; i < 5; i++) {
        blocks.push({
          x: Math.random() * (canvas.width - 40),
          y: Math.random() * -200,
          width: 40,
          height: 20,
          dy: 2 + Math.random() * 2
        });
      }
    }

    function initGame3() {
      ball = { x: 200, y: 200, radius: 20, dx: 3, dy: 3 };
    }

    async function predictFrame() {
      const prediction = await model.predict(webcamElement);
      let highest = prediction.reduce((p, c) => (c.probability > p.probability ? c : p));
      return highest.className;
    }

    async function gameLoop() {
      if (gameState === "paused") return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (currentClass === 1) {
        // CLASS 1: Ball Catch
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = "orange";
        ctx.fill();

        ctx.fillStyle = "#4caf50";
        ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

        ball.x += ball.dx;
        ball.y += ball.dy;

        if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) ball.dx *= -1;
        if (ball.y - ball.radius < 0) ball.dy *= -1;

        if (ball.y + ball.radius > canvas.height) {
          ball.y = 200; ball.dy = -ball.dy;
        }

        let detected = await predictFrame();
        if (detected === "Class 1") {
          paddle.x = 170; // steady paddle
          if (ball.y + ball.radius > paddle.y && ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
            ball.dy *= -1;
            setStatus("Nice catch! Continue?");
            btnContinue.style.display = "inline-block";
          }
        }

      } else if (currentClass === 2) {
        // CLASS 2: Falling Blocks
        for (let b of blocks) {
          b.y += b.dy;
          ctx.fillStyle = "skyblue";
          ctx.fillRect(b.x, b.y, b.width, b.height);
          if (b.y > canvas.height) {
            b.y = -20;
            b.x = Math.random() * (canvas.width - 40);
          }
        }

        let detected = await predictFrame();
        if (detected === "Class 2") {
          setStatus("Blocks avoided! Continue?");
          btnContinue.style.display = "inline-block";
        }

      } else if (currentClass === 3) {
        // CLASS 3: Moving Ball Challenge
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = "yellow";
        ctx.fill();
        ball.x += ball.dx;
        ball.y += ball.dy;

        if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) ball.dx *= -1;
        if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) ball.dy *= -1;

        let detected = await predictFrame();
        if (detected === "Class 3") {
          setStatus("You completed all classes! ðŸŽ‰");
          btnContinue.style.display = "none";
        }
      }

      requestAnimationFrame(gameLoop);
    }

    // -------------------------
    // BUTTON CONTROLS
    // -------------------------
    btnStart.onclick = async () => {
      try {
        btnStart.disabled = true;
        setStatus("Starting...");
        await loadModel();
        await startWebcam();
        setStatus("Game 1 Starting...");
        btnStart.style.display = "none";
        btnPause.style.display = "inline-block";
        btnRestart.style.display = "inline-block";
        initGame1();
        gameState = "running";
        requestAnimationFrame(gameLoop);
      } catch (err) {
        console.error(err);
        setStatus("Error loading model or webcam.");
      } finally {
        btnStart.disabled = false;
      }
    };

    btnContinue.onclick = () => {
      btnContinue.style.display = "none";
      if (currentClass === 1) {
        currentClass = 2;
        initGame2();
        setStatus("Game 2 starting...");
      } else if (currentClass === 2) {
        currentClass = 3;
        initGame3();
        setStatus("Game 3 starting...");
      } else {
        setStatus("All levels complete!");
      }
    };

    btnPause.onclick = () => {
      if (gameState === "paused") {
        gameState = "running";
        setStatus("Resumed");
        requestAnimationFrame(gameLoop);
      } else {
        gameState = "paused";
        setStatus("Paused");
      }
    };

    btnRestart.onclick = () => {
      location.reload();
    };
  </script>
</body>
</html>
