<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3-Class Rehab Game Suite</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
<style>
  /* ... (CSS remains exactly the same) ... */
</style>
</head>
<body>
  <!-- ... (HTML remains exactly the same) ... -->
</body>
</html>

<script>
/* -------------------------
   CONFIG (tweak here)
   ------------------------- */
const MODEL_URL = "https://teachablemachine.withgoogle.com/models/ZwgUkHwE_/";
const UPDATE_INTERVAL = 600;
const CLASS_INDEX = { c1: 0, c2: 1, c3: 2 };
const THRESH = { c1: 0.7, c2: 0.6, c3: 0.65 };
const LATCH_MS = 1000;
const GOAL_PER_GAME = 7;

/* -------------------------
   State & game variables
   ------------------------- */
let model, webcam, labelContainer, maxPredictions;
let lastPredTime = 0;
let lastPredictions = [0,0,0];

let gestureCatch1 = 0;
let gestureCatch2 = 0;
let gestureCatch3 = 0;

let canvas = document.getElementById('gameCanvas');
let ctx = canvas.getContext('2d');
let confCanvas = document.getElementById('confettiCanvas');
let confCtx = confCanvas.getContext('2d');
let flash = document.getElementById('flash');
let centerText = document.getElementById('centerText');
let btnStart = document.getElementById('btnStart');
let btnPause = document.getElementById('btnPause');
let btnRestart = document.getElementById('btnRestart');
let continueBtn = document.getElementById('continueBtn');

let gameState = 'idle';
let gameIndex = 0;
let scores = [0,0,0];
let roundsPlayed = 0;

let ball = { x:200, y:-20, r:14, speed:1.2, active:true, waitingContinue:false };
let paddle = { x:200, w:120 };
let boxList = [];
let boxSpeed = 1.0;
let rotateProgress = 0;
let rotateTarget = 360;
let confetti = [];

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function beep(freq=440, time=0.12, type='sine'){
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.2, audioCtx.currentTime + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + time);
  o.stop(audioCtx.currentTime + time + 0.02);
}
function playWin(){
  beep(880,0.12,'sine'); setTimeout(()=>beep(660,0.12,'sine'),120);
}
function playFail(){ beep(180,0.25,'sawtooth'); }

function setStatus(text){ document.getElementById('status').innerText = 'Status: ' + text; }
function setGameName(name){ document.getElementById('gameName').innerText = name; }
function setScore(n){ document.getElementById('score').innerText = n; }
function setGoal(n){ document.getElementById('goal').innerText = n; }
function setLastResult(text){ document.getElementById('lastResult').innerText = text; }
function updateSummaries(){
  document.getElementById('sum1').innerText = `${scores[0]} / ${GOAL_PER_GAME}`;
  document.getElementById('sum2').innerText = `${scores[1]} / ${GOAL_PER_GAME}`;
  document.getElementById('sum3').innerText = `${scores[2]} / ${GOAL_PER_GAME}`;
}

async function loadModel(){
  setStatus('Loading model...');
  const modelURL = MODEL_URL + 'model.json';
  const metadataURL = MODEL_URL + 'metadata.json';
  model = await tmImage.load(modelURL, metadataURL);
  maxPredictions = model.getTotalClasses();
  labelContainer = {
    0: document.getElementById('class0'),
    1: document.getElementById('class1'),
    2: document.getElementById('class2')
  };
  setStatus('Model loaded. Click Start.');
}

async function startWebcam(){
  const flip = true;
  webcam = new tmImage.Webcam(320, 320, flip);
  await webcam.setup();
  await webcam.play();
  const container = document.getElementById('webcam-container');
  container.innerHTML = '';
  container.appendChild(webcam.canvas);
}

async function predictionTick(timestamp){
  if(!webcam || !model) return;
  webcam.update();
  const now = performance.now();
  if(now - lastPredTime >= UPDATE_INTERVAL){
    lastPredTime = now;
    const preds = await model.predict(webcam.canvas);
    for(let i=0;i<Math.min(3,preds.length);i++){
      lastPredictions[i] = preds[i].probability;
      labelContainer[i].innerText = `${preds[i].className}: ${(preds[i].probability*100).toFixed(2)}%`;
    }
    if(lastPredictions[CLASS_INDEX.c1] >= THRESH.c1) gestureCatch1 = performance.now();
    if(lastPredictions[CLASS_INDEX.c2] >= THRESH.c2) gestureCatch2 = performance.now();
    if(lastPredictions[CLASS_INDEX.c3] >= THRESH.c3) gestureCatch3 = performance.now();
    updateLabelHighlights();
  }
}

function updateLabelHighlights(){
  for(let i=0;i<3;i++){
    const el = labelContainer[i];
    if(!el) continue;
    const prob = lastPredictions[i] || 0;
    if(prob >= (i===CLASS_INDEX.c1?THRESH.c1:(i===CLASS_INDEX.c2?THRESH.c2:THRESH.c3))){
      el.classList.add('detected');
    } else {
      el.classList.remove('detected');
    }
  }
}

let lastFrame = 0;
function gameLoop(ts){
  const now = ts || performance.now();
  const dt = Math.min(40, now - lastFrame);
  lastFrame = now;

  predictionTick();

  ctx.clearRect(0,0,canvas.width,canvas.height);

  if(gameState === 'idle'){
    drawCenterText('Press START to begin', '#1E2E4F');
  } else if(gameState === 'game1'){
    runGame1(dt);
  } else if(gameState === 'inter1'){
    drawTransition('Class 1 finished', `Score: ${scores[0]} / ${GOAL_PER_GAME}`, 'Play Next');
  } else if(gameState === 'game2'){
    runGame2(dt);
  } else if(gameState === 'inter2'){
    drawTransition('Class 2 finished', `Score: ${scores[1]} / ${GOAL_PER_GAME}`, 'Play Next');
  } else if(gameState === 'game3'){
    runGame3(dt);
  } else if(gameState === 'end'){
    drawEndScreen();
  } else if(gameState === 'paused'){
    drawCenterText('Paused', '#1E2E4F');
  }

  drawConfetti(dt);
  requestAnimationFrame(gameLoop);
}

function drawCenterText(text, color='#1E2E4F'){
  centerText.style.display='block';
  centerText.style.color = color;
  centerText.innerText = text;
}
function hideCenterText(){ centerText.style.display='none'; }

function runGame1(dt){
  hideCenterText();
  continueBtn.style.display = ball.waitingContinue ? 'inline-block' : 'none';
  setGameName('Ball Catch — Class 1 (open/close palm)');
  setStatus('Perform Class 1 gesture to catch when ball near bottom');
  btnPause.style.display='inline-block';
  btnRestart.style.display='inline-block';

  const catchY = canvas.height - 60;
  ctx.fillStyle = 'rgba(50,200,100,0.06)';
  ctx.fillRect(0, catchY, canvas.width, 60);

  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
  ctx.fillStyle = '#E43D40';
  ctx.fill();
  ctx.closePath();

  if(ball.active && !ball.waitingContinue){
    ball.y += ball.speed;
  }

  const class1Prob = lastPredictions[CLASS_INDEX.c1] || 0;
  if(ball.active && !ball.waitingContinue){
    if(ball.y >= catchY && ball.y <= canvas.height - 10){
      ctx.fillStyle = '#000';
      ctx.font = '14px Poppins';
      ctx.fillText('Perform Class1 to catch', 12, catchY - 10);

      if(performance.now() - gestureCatch1 < LATCH_MS){
        ball.active = false;
        ball.waitingContinue = true;
        onWin(0);
        gestureCatch1 = 0;
        continueBtn.style.display = 'inline-block';
      }
    }
    if(ball.y > canvas.height + 20){
      ball.active = false;
      onFail(0);
      setTimeout(()=> resetBall(), 450);
    }
  }

  ctx.fillStyle = '#000';
  ctx.font = '14px Poppins';
  ctx.fillText(`Ball ${roundsPlayed+1} / ${GOAL_PER_GAME}`, 12, 20);
  ctx.fillText(`Class1: ${(class1Prob*100).toFixed(0)}%`, 12, 40);
}

function resetBall(){
  ball.x = 30 + Math.random()*(canvas.width-60);
  ball.y = -20;
  ball.r = 16;
  ball.speed = 1.1;
  ball.active = true;
  ball.waitingContinue = false;
  roundsPlayed++;
  if(roundsPlayed >= GOAL_PER_GAME){
    setTimeout(()=> {
      gameState = 'inter1';
      setLastResult(`Score: ${scores[0]} / ${GOAL_PER_GAME}`);
      setStatus('Finished Class 1');
      setScore(scores[0]);
      updateSummaries();
      roundsPlayed = 0;
      continueBtn.style.display = 'none';
    }, 500);
  } else {
    continueBtn.style.display = 'none';
  }
}

continueBtn.onclick = () => {
  if(gameState !== 'game1') return;
  if(ball.waitingContinue){
    resetBall();
  }
};

function spawnBox(){
  boxList.push({ x: 60 + Math.random() * (canvas.width - 120), y: -30, w: 28, h: 28, caught:false });
}

function runGame2(dt){
  hideCenterText();
  setGameName('Wrist Move — Class 2');
  setStatus('Perform Class 2 (move wrist) to shift paddle and catch boxes');
  btnPause.style.display='inline-block';
  btnRestart.style.display='inline-block';

  const pY = canvas.height - 40;
  ctx.fillStyle = '#2B63A6';
  ctx.fillRect(paddle.x - paddle.w/2, pY, paddle.w, 12);
  
  for(let i=0;i<boxList.length;i++){
    const b = boxList[i];
    ctx.fillStyle = '#F5A623';
    ctx.fillRect(b.x, b.y, b.w, b.h);
    b.y += boxSpeed;
  }

  if(boxList.length < 3 && Math.random() < 0.015) spawnBox();

  const class2Prob = lastPredictions[CLASS_INDEX.c2] || 0;
  if(performance.now() - gestureCatch2 < LATCH_MS) {
    paddle.x += 4 * (0.6 + class2Prob);
  } else {
    paddle.x -= 1.5;
  }
  if(paddle.x < paddle.w/2) paddle.x = paddle.w/2;
  if(paddle.x > canvas.width - paddle.w/2) paddle.x = canvas.width - paddle.w/2;

  for(let i = boxList.length-1; i>=0; i--){
    const b = boxList[i];
    if(b.y > canvas.height){
      boxList.splice(i,1);
      roundsPlayed++;
      onFail(1);
      continue;
    }
    if(b.y + b.h >= pY && b.y <= pY + 12 && b.x < paddle.x + paddle.w/2 && b.x + b.w > paddle.x - paddle.w/2){
      boxList.splice(i,1);
      roundsPlayed++;
      onWin(1);
      continue;
    }
  }

  ctx.fillStyle = '#000';
  ctx.font = '14px Poppins';
  ctx.fillText(`Boxes caught: ${scores[1]} / ${GOAL_PER_GAME}`, 12, 20);
  ctx.fillText(`Class2: ${(class2Prob*100).toFixed(0)}%`, 12, 40);

  if(roundsPlayed >= GOAL_PER_GAME){
    setTimeout(()=> {
      gameState = 'inter2';
      setLastResult(`Score: ${scores[1]} / ${GOAL_PER_GAME}`);
      setStatus('Finished Class 2');
      setScore(scores[1]);
      updateSummaries();
      roundsPlayed = 0;
      boxList = [];
    }, 600);
  }
} // <- THIS WAS THE MISSING CLOSING BRACE for runGame2

function runGame3(dt){
  hideCenterText();
  setGameName('Fist Rotate — Class 3');
  setStatus('Perform Class 3 (fist rotate) and hold to fill the meter');
  btnPause.style.display='inline-block';
  btnRestart.style.display='inline-block';

  const centerX = canvas.width/2;
  const centerY = canvas.height/2;
  ctx.beginPath();
  ctx.arc(centerX, centerY - 20, 70, 0, Math.PI*2);
  ctx.fillStyle = '#eef6ff';
  ctx.fill(); ctx.closePath();

  const class3Prob = lastPredictions[CLASS_INDEX.c3] || 0;
  ctx.fillStyle = '#222';
  ctx.font = '14px Poppins';
  ctx.fillText(`Class3: ${(class3Prob*100).toFixed(0)}%`, 12, 20);

  if(performance.now() - gestureCatch3 < LATCH_MS){
    rotateProgress += 2 * (0.5 + class3Prob*1.0);
  } else {
    rotateProgress -= 1.2;
  }
  if(rotateProgress < 0) rotateProgress = 0;
  if(rotateProgress > rotateTarget) rotateProgress = rotateTarget;

  const pct = rotateProgress / rotateTarget;
  ctx.beginPath();
  ctx.arc(centerX, centerY - 20, 70, -Math.PI/2, -Math.PI/2 + pct * Math.PI*2);
  ctx.strokeStyle = '#2B63A6';
  ctx.lineWidth = 12;
  ctx.stroke(); ctx.closePath();

  ctx.fillStyle = '#1E2E4F';
  ctx.font = '18px Poppins';
  ctx.textAlign='center';
  ctx.fillText(Math.floor(pct*100) + '%', centerX, centerY - 18);

  if(rotateProgress >= rotateTarget){
    rotateProgress = 0;
    roundsPlayed++;
    onWin(2);
  }

  ctx.textAlign='left';
  ctx.fillStyle='#000';
  ctx.font='14px Poppins';
  ctx.fillText(`Round ${roundsPlayed+1} / ${GOAL_PER_GAME}`, 12, canvas.height - 20);

  if(roundsPlayed >= GOAL_PER_GAME){
    setTimeout(()=> {
      gameState = 'end';
      setLastResult(`Score: ${scores[2]} / ${GOAL_PER_GAME}`);
      setStatus('Finished Class 3');
      setScore(scores[2]);
      updateSummaries();
      roundsPlayed = 0;
    }, 600);
  }
}

function onWin(gameIdx){
  scores[gameIdx] = Math.min(GOAL_PER_GAME, scores[gameIdx] + 1);
  setScore(scores[gameIdx]);
  setLastResult('Win!');
  updateSummaries();
  playWin();
  spawnConfetti();
  showFlash(false);
  centerText.style.display='block';
  centerText.innerText = 'Great! ✔';
  setTimeout(()=> centerText.style.display='none', 800);
}

function onFail(gameIdx){
  setLastResult('Miss');
  setStatus('Try again');
  playFail();
  showFlash(true);
  centerText.style.display='block';
  centerText.innerText = 'Missed ❌';
  setTimeout(()=> {
    centerText.style.display='none';
    showFlash(false);
  }, 900);
}

function showFlash(isFail){
  if(isFail){
    flash.style.opacity = 1;
    setTimeout(()=> { flash.style.opacity = 0; }, 600);
  } else {
    flash.style.opacity = 0;
  }
}

function spawnConfetti(){
  for(let i=0;i<40;i++){
    confetti.push({
      x: canvas.width * 0.5 + (Math.random()-0.5)*200,
      y: 20 + Math.random()*40,
      vx: (Math.random()-0.5)*3,
      vy: 1 + Math.random()*3,
      size: 4 + Math.random()*6,
      life: 100 + Math.random()*80,
      color: ['#FF3B30','#FF9500','#34C759','#007AFF','#AF52DE'][Math.floor(Math.random()*5)]
    });
  }
}

function drawConfetti(dt){
  confCtx.clearRect(0,0,confCanvas.width,confCanvas.height);
  for(let i=confetti.length-1;i>=0;i--){
    const p = confetti[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.06;
    p.life -= 1;
    confCtx.fillStyle = p.color;
    confCtx.fillRect(p.x, p.y, p.size, p.size*0.6);
    if(p.life <= 0 || p.y > confCanvas.height + 30) confetti.splice(i,1);
  }
}

function drawTransition(title, subtitle, btnText){
  centerText.style.display='block';
  centerText.innerText = `${title}\n${subtitle}\n\nPress START to continue`;
  btnStart.style.display = 'inline-block';
}

function drawEndScreen(){
  centerText.style.display='block';
  centerText.innerText = `All games finished!\n\nResults:\nClass1: ${scores[0]} / ${GOAL_PER_GAME}\nClass2: ${scores[1]} / ${GOAL_PER_GAME}\nClass3: ${scores[2]} / ${GOAL_PER_GAME}\n\nPress Restart to play again.`;
  btnStart.style.display='none';
  btnRestart.style.display='inline-block';
  btnPause.style.display='none';
}

btnStart.onclick = async ()=>{
  if(!model){
    await loadModel();
    await startWebcam();
  }
  if(gameState === 'idle'){
    gameState = 'game1'; gameIndex = 0;
    roundsPlayed = 0;
    scores = [0,0,0];
    updateSummaries();
    setScore(0);
    setGoal(GOAL_PER_GAME);
    btnStart.style.display='none';
    btnPause.style.display='inline-block';
    btnRestart.style.display='inline-block';
    centerText.style.display='none';
    resetBall();
  } else if(gameState === 'inter1'){
    gameState = 'game2';
    gameIndex = 1;
    roundsPlayed = 0; setScore(scores[1]); setGoal(GOAL_PER_GAME);
    centerText.style.display='none'; btnStart.style.display='none';
  } else if(gameState === 'inter2'){
    gameState = 'game3';
    gameIndex = 2;
    roundsPlayed = 0; setScore(scores[2]); setGoal(GOAL_PER_GAME);
    centerText.style.display='none'; btnStart.style.display='none';
  }
};
  
btnPause.onclick = ()=>{
  if(gameState !== 'paused'){ gameState = 'paused'; btnPause.innerText='Resume'; setStatus('Paused'); }
  else {
    if(gameIndex === 0) gameState='game1';
    else if(gameIndex === 1) gameState='game2';
    else if(gameIndex === 2) gameState='game3';
    btnPause.innerText='Pause';
  }
};

btnRestart.onclick = ()=>{
  scores = [0,0,0]; roundsPlayed=0; updateSummaries(); setScore(0); setGoal(GOAL_PER_GAME);
  gameState = 'idle';
  btnStart.style.display='inline-block';
  btnRestart.style.display='none';
  btnPause.style.display='none';
  centerText.style.display='block';
  centerText.innerText = 'Press START to begin';
  setStatus('Waiting');
  ball = { x:200, y:-20, r:14, speed:1.2, active:true, waitingContinue:false };
  boxList = [];
  rotateProgress = 0;
};

(async function initAll(){
  setGoal(GOAL_PER_GAME);
  setStatus('Ready (model not loaded)');
  requestAnimationFrame(gameLoop);
})();
</script>
