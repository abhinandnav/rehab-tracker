/* -------------------------
   CONFIG (tweak here)
   ------------------------- */
const MODEL_URL = "https://teachablemachine.withgoogle.com/models/ZwgUkHwE_/"; // keep your model base URL here
const UPDATE_INTERVAL = 600; // ms  — prediction frequency
const CLASS_INDEX = { c1: 0, c2: 1, c3: 2 }; // if your model classes order differs, change indices
const THRESH = { c1: 0.7, c2: 0.6, c3: 0.65 }; // detection thresholds
const LATCH_MS = 1000; // how long to remember a detected gesture (ms)
const GOAL_PER_GAME = 7; // number of successful rounds per game

/* -------------------------
   State & game variables
   ------------------------- */
let model, webcam, labelContainer, maxPredictions;
let lastPredTime = 0;
let lastPredictions = [0,0,0];

// gesture latch timestamps (when model last saw the gesture)
let gestureCatch1 = 0;
let gestureCatch2 = 0;
let gestureCatch3 = 0;

let canvas = document.getElementById('gameCanvas');
let ctx = canvas.getContext('2d');
let confCanvas = document.getElementById('confettiCanvas');
let confCtx = confCanvas.getContext('2d');
let flash = document.getElementById('flash');
let centerText = document.getElementById('centerText');
let btnStart = document.getElementById('btnStart');
let btnPause = document.getElementById('btnPause');
let btnRestart = document.getElementById('btnRestart');
let continueBtn = document.getElementById('continueBtn');

let gameState = 'idle'; // idle, game1, inter1, game2, inter2, game3, end, paused
let gameIndex = 0; // 0..2
let scores = [0,0,0];
let roundsPlayed = 0;

/* --- Game1 (ball catch) --- */
let ball = { x:200, y:-20, r:14, speed:1.2, active:true, waitingContinue:false };

/* --- Game2 (wrist move paddle) --- */
let paddle = { x:200, w:120 }; // paddle responds to class2 detection
let boxList = []; // falling boxes(top to bottom) to catch
let boxSpeed = 1.0;

/* --- Game3 (fist rotation) --- */
let rotateProgress = 0; // 0..360 degrees; user must sustain class3 to fill
let rotateTarget = 360;

/* --- Confetti particles --- */
let confetti = [];

/* --- Audio (WebAudio) --- */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function beep(freq=440, time=0.12, type='sine'){
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.2, audioCtx.currentTime + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + time);
  o.stop(audioCtx.currentTime + time + 0.02);
}
function playWin(){
  beep(880,0.12,'sine'); setTimeout(()=>beep(660,0.12,'sine'),120);
}
function playFail(){ beep(180,0.25,'sawtooth'); }

/* -------------------------
   UTIL / UI updates
   ------------------------- */
function setStatus(text){ document.getElementById('status').innerText = 'Status: ' + text; }
function setGameName(name){ document.getElementById('gameName').innerText = name; }
function setScore(n){ document.getElementById('score').innerText = n; }
function setGoal(n){ document.getElementById('goal').innerText = n; }
function setLastResult(text){ document.getElementById('lastResult').innerText = text; }
function updateSummaries(){
  document.getElementById('sum1').innerText = `${scores[0]} / ${GOAL_PER_GAME}`;
  document.getElementById('sum2').innerText = `${scores[1]} / ${GOAL_PER_GAME}`;
  document.getElementById('sum3').innerText = `${scores[2]} / ${GOAL_PER_GAME}`;
}

/* -------------------------
   MODEL + WEBCAM LOADING
   ------------------------- */
async function loadModel(){
  setStatus('Loading model...');
  const modelURL = MODEL_URL + 'model.json';
  const metadataURL = MODEL_URL + 'metadata.json';
  model = await tmImage.load(modelURL, metadataURL);
  maxPredictions = model.getTotalClasses();
  labelContainer = {
    0: document.getElementById('class0'),
    1: document.getElementById('class1'),
    2: document.getElementById('class2')
  };
  setStatus('Model loaded. Click Start.');
}

async function startWebcam(){
  const flip = true;
  webcam = new tmImage.Webcam(320, 320, flip);
  await webcam.setup();
  await webcam.play();
  const container = document.getElementById('webcam-container');
  container.innerHTML = '';
  container.appendChild(webcam.canvas);
}

/* -------------------------
   PREDICTION LOOP
   ------------------------- */
async function predictionTick(timestamp){
  if(!webcam || !model) return;
  webcam.update();
  const now = performance.now();
  if(now - lastPredTime >= UPDATE_INTERVAL){
    lastPredTime = now;
    const preds = await model.predict(webcam.canvas);
    // map probabilities into lastPredictions and UI
    for(let i=0;i<Math.min(3,preds.length);i++){
      lastPredictions[i] = preds[i].probability;
      labelContainer[i].innerText = `${preds[i].className}: ${(preds[i].probability*100).toFixed(2)}%`;
    }
    // Latch gestures: store timestamps when above threshold
    if(lastPredictions[CLASS_INDEX.c1] >= THRESH.c1) gestureCatch1 = performance.now();
    if(lastPredictions[CLASS_INDEX.c2] >= THRESH.c2) gestureCatch2 = performance.now();
    if(lastPredictions[CLASS_INDEX.c3] >= THRESH.c3) gestureCatch3 = performance.now();

    // add simple UI highlight when detection is active
    updateLabelHighlights();
  }
}

function updateLabelHighlights(){
  for(let i=0;i<3;i++){
    const el = labelContainer[i];
    if(!el) continue;
    const prob = lastPredictions[i] || 0;
    if(prob >= (i===CLASS_INDEX.c1?THRESH.c1:(i===CLASS_INDEX.c2?THRESH.c2:THRESH.c3))){
      el.classList.add('detected');
    } else {
      el.classList.remove('detected');
    }
  }
}

/* -------------------------
   GAME DRAW / LOGIC LOOP
   ------------------------- */
let lastFrame = 0;
function gameLoop(ts){
  const now = ts || performance.now();
  const dt = Math.min(40, now - lastFrame);
  lastFrame = now;

  // run prediction tick occasionally
  predictionTick();

  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // routing by state
  if(gameState === 'idle'){
    drawCenterText('Press START to begin', '#1E2E4F');
  } else if(gameState === 'game1'){
    runGame1(dt);
  } else if(gameState === 'inter1'){
    drawTransition('Class 1 finished', `Score: ${scores[0]} / ${GOAL_PER_GAME}`, 'Play Next');
  } else if(gameState === 'game2'){
    runGame2(dt);
  } else if(gameState === 'inter2'){
    drawTransition('Class 2 finished', `Score: ${scores[1]} / ${GOAL_PER_GAME}`, 'Play Next');
  } else if(gameState === 'game3'){
    runGame3(dt);
  } else if(gameState === 'end'){
    drawEndScreen();
  } else if(gameState === 'paused'){
    drawCenterText('Paused', '#1E2E4F');
  }

  // confetti draw
  drawConfetti(dt);

  requestAnimationFrame(gameLoop);
}

/* -------------------------
   DRAW HELPERS
   ------------------------- */
function drawCenterText(text, color='#1E2E4F'){
  centerText.style.display='block';
  centerText.style.color = color;
  centerText.innerText = text;
}
function hideCenterText(){ centerText.style.display='none'; }

/* -------------------------
   GAME1: Ball Catch
   - ball falls slowly; user must trigger class1 when ball near bottom
   - if class1 detected (> THRESH.c1) while ball.y in catch zone -> success
   - otherwise when ball passes bottom -> fail
   - On success: show Continue button. Only when user presses Continue the next ball drops.
   ------------------------- */
function runGame1(dt){
  hideCenterText();
  continueBtn.style.display = ball.waitingContinue ? 'inline-block' : 'none';
  setGameName('Ball Catch — Class 1 (open/close palm)');
  setStatus('Perform Class 1 gesture to catch when ball near bottom');
  btnPause.style.display='inline-block';
  btnRestart.style.display='inline-block';

  // draw ground indicator (catch zone)
  const catchY = canvas.height - 60;
  ctx.fillStyle = 'rgba(50,200,100,0.06)';
  ctx.fillRect(0, catchY, canvas.width, 60);

  // draw ball
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
  ctx.fillStyle = '#E43D40';
  ctx.fill();
  ctx.closePath();

  // move ball only if active and not waiting for continue
  if(ball.active && !ball.waitingContinue){
    ball.y += ball.speed; // beginner-friendly slow
  }

  // check catch condition
  const class1Prob = lastPredictions[CLASS_INDEX.c1] || 0;
  if(ball.active && !ball.waitingContinue){
    // If ball is in catch zone, check for gesture within latch window
    if(ball.y >= catchY && ball.y <= canvas.height - 10){
      // show prompt
      ctx.fillStyle = '#000';
      ctx.font = '14px Poppins';
      ctx.fillText('Perform Class1 to catch', 12, catchY - 10);

      // consider latched gesture (within LATCH_MS)
      if(performance.now() - gestureCatch1 < LATCH_MS){
        // caught
        ball.active = false;
        ball.waitingContinue = true; // pause until Continue clicked
        onWin(0);
        // reset gesture latch so it does not re-fire
        gestureCatch1 = 0;
        // show continue button
        continueBtn.style.display = 'inline-block';
      }
    }
    // if ball goes beyond bottom
    if(ball.y > canvas.height + 20){
      // treat as failed catch
      ball.active = false;
      onFail(0);
      // auto reset after short delay
      setTimeout(()=> resetBall(), 450);
    }
  }

  // HUD: show progress and status
  ctx.fillStyle = '#000';
  ctx.font = '14px Poppins';
  ctx.fillText(`Ball ${roundsPlayed+1} / ${GOAL_PER_GAME}`, 12, 20);
  ctx.fillText(`Class1: ${(class1Prob*100).toFixed(0)}%`, 12, 40);
}

/* reset ball */
function resetBall(){
  // prepare next ball
  ball.x = 30 + Math.random()*(canvas.width-60);
  ball.y = -20;
  ball.r = 16;
  ball.speed = 1.1; // slow
  ball.active = true;
  ball.waitingContinue = false;
  roundsPlayed++;
  // if finished this game's rounds
  if(roundsPlayed >= GOAL_PER_GAME){
    // end game1
    setTimeout(()=> {
      gameState = 'inter1';
      setLastResult(`Score: ${scores[0]} / ${GOAL_PER_GAME}`);
      setStatus('Finished Class 1');
      setScore(scores[0]);
      updateSummaries();
      roundsPlayed = 0;
      // small UI changes handled globally
      continueBtn.style.display = 'none';
    }, 500);
  } else {
    // hide continue button (if visible)
    continueBtn.style.display = 'none';
  }
}

/* Continue button behaviour (for Game1) */
continueBtn.onclick = () => {
  // Only allow continue in game1 waiting state
  if(gameState !== 'game1') return;
  if(ball.waitingContinue){
    // Move to next round (this increments roundsPlayed in resetBall)
    resetBall();
  }
};

/* -------------------------
   GAME2: Wrist Move (Class2)
   - boxes come from top; paddle controlled by class2 probability: when class2 detected, paddle moves right
   - simple smoothing: use latched gesture to give a stronger response
   ------------------------- */
function spawnBox(){
  boxList.push({ x: 60 + Math.random() * (canvas.width - 120), y: -30, w: 28, h: 28, caught:false });
}

function runGame2(dt){
  hideCenterText();
  setGameName('Wrist Move — Class 2');
  setStatus('Perform Class 2 (move wrist) to shift paddle and catch boxes');
  btnPause.style.display='inline-block';
  btnRestart.style.display='inline-block';

  // draw paddle at bottom
  const pY = canvas.height - 40;
  ctx.fillStyle = '#2B63A6';
  ctx.fillRect(paddle.x - paddle.w/2, pY, paddle.w, 12);
  // draw boxes
  for(let i=0;i<boxList.length;i++){
    const b = boxList[i];
    ctx.fillStyle = '#F5A623';
    ctx.fillRect(b.x, b.y, b.w, b.h);
    // move boxes vertically downwards
    b.y += boxSpeed;
  }

  // occasionally spawn boxes if less than some
  if(boxList.length < 3 && Math.random() < 0.015) spawnBox();

  // control paddle using class2 detection:
  const class2Prob = lastPredictions[CLASS_INDEX.c2] || 0;
  // If class2 latched (recent), move paddle right with boost; else drift left slightly
  if(performance.now() - gestureCatch2 < LATCH_MS) {
    paddle.x += 4 * (0.6 + class2Prob);
  } else {
    paddle.x -= 1.5;
  }
  // clamp
  if(paddle.x < paddle.w/2) paddle.x = paddle.w/2;
  if(paddle.x > canvas.width - paddle.w/2) paddle.x = canvas.width - paddle.w/2;

  // check collisions: if a box reaches paddle region -> check catch
  for(let i = boxList.length-1; i>=0; i--){
    const b = boxList[i];
    // if box hits left edge (missed) => remove and mark fail
    if(b.x + b.w < 0){
      boxList.splice(i,1);
      roundsPlayed++;
      onFail(1); // a missed box
      continue;
    }
    // if box intersects paddle
    if(b.y + b.h >= pY && b.y <= pY + 12 && b.x < paddle.x + paddle.w/2 && b.x + b.w > paddle.x - paddle.w/2){
      // caught
      boxList.splice(i,1);
      roundsPlayed++;
      onWin(1);
      continue;
    }
  }

  // HUD
  ctx.fillStyle = '#000';
  ctx.font = '14px Poppins';
  ctx.fillText(`Boxes caught: ${scores[1]} / ${GOAL_PER_GAME}`, 12, 20);
  ctx.fillText(`Class2: ${(class2Prob*100).toFixed(0)}%`, 12, 40);

  // if rounds complete
  if(roundsPlayed >= GOAL_PER_GAME){
    setTimeout(()=> {
      gameState = 'inter2';
      setLastResult(`Score: ${scores[1]} / ${GOAL_PER_GAME}`);
      setStatus('Finished Class 2');
      setScore(scores[1]);
      updateSummaries();
      roundsPlayed = 0;
      boxList = [];
    }, 600);
  }
}

/* -------------------------
   GAME3: Fist Rotation (Class3)
   - show circular meter; when class3 detected, meter fills; user must hold to fill the meter
   - latched detection makes it more forgiving
   ------------------------- */
function runGame3(dt){
  hideCenterText();
  setGameName('Fist Rotate — Class 3');
  setStatus('Perform Class 3 (fist rotate) and hold to fill the meter');
  btnPause.style.display='inline-block';
  btnRestart.style.display='inline-block';

  const centerX = canvas.width/2;
  const centerY = canvas.height/2;
  // background circle
  ctx.beginPath();
  ctx.arc(centerX, centerY - 20, 70, 0, Math.PI*2);
  ctx.fillStyle = '#eef6ff';
  ctx.fill(); ctx.closePath();

  // get class3 prob
  const class3Prob = lastPredictions[CLASS_INDEX.c3] || 0;
  ctx.fillStyle = '#222';
  ctx.font = '14px Poppins';
  ctx.fillText(`Class3: ${(class3Prob*100).toFixed(0)}%`, 12, 20);

  // increase rotateProgress only when class3 latched
  if(performance.now() - gestureCatch3 < LATCH_MS){
    // fill speed proportional to probability (gentle)
    rotateProgress += 2 * (0.5 + class3Prob*1.0);
  } else {
    // slight decay so user needs sustained gesture
    rotateProgress -= 1.2;
  }
  if(rotateProgress < 0) rotateProgress = 0;
  if(rotateProgress > rotateTarget) rotateProgress = rotateTarget;

  // draw arc for progress
  const pct = rotateProgress / rotateTarget;
  ctx.beginPath();
  ctx.arc(centerX, centerY - 20, 70, -Math.PI/2, -Math.PI/2 + pct * Math.PI*2);
  ctx.strokeStyle = '#2B63A6';
  ctx.lineWidth = 12;
  ctx.stroke(); ctx.closePath();

  // center text
  ctx.fillStyle = '#1E2E4F';
  ctx.font = '18px Poppins';
  ctx.textAlign='center';
  ctx.fillText(Math.floor(pct*100) + '%', centerX, centerY - 18);

  // when completed
  if(rotateProgress >= rotateTarget){
    rotateProgress = 0;
    roundsPlayed++;
    onWin(2);
  }

  // display rounds
  ctx.textAlign='left';
  ctx.fillStyle='#000';
  ctx.font='14px Poppins';
  ctx.fillText(`Round ${roundsPlayed+1} / ${GOAL_PER_GAME}`, 12, canvas.height - 20);

  // if finished
  if(roundsPlayed >= GOAL_PER_GAME){
    setTimeout(()=> {
      gameState = 'end';
      setLastResult(`Score: ${scores[2]} / ${GOAL_PER_GAME}`);
      setStatus('Finished Class 3');
      setScore(scores[2]);
      updateSummaries();
      roundsPlayed = 0;
    }, 600);
  }
}

/* -------------------------
   WIN / FAIL HANDLERS: visual + audio + state updates
   ------------------------- */
function onWin(gameIdx){
  // add to score
  scores[gameIdx] = Math.min(GOAL_PER_GAME, scores[gameIdx] + 1);
  setScore(scores[gameIdx]);
  setLastResult('Win!');
  updateSummaries();
  playWin();
  spawnConfetti();
  showFlash(false);
  // small center message
  centerText.style.display='block';
  centerText.innerText = 'Great! ✔';
  setTimeout(()=> centerText.style.display='none', 800);
  // if game1: we pause for continue (handled in runGame1)
  // for other games we continue automatically
}

function onFail(gameIdx){
  setLastResult('Miss');
  setStatus('Try again');
  playFail();
  showFlash(true);
  centerText.style.display='block';
  centerText.innerText = 'Missed ❌';
  setTimeout(()=> {
    centerText.style.display='none';
    showFlash(false);
  }, 900);
}

/* -------------------------
   Flash & Confetti
   ------------------------- */
function showFlash(isFail){
  if(isFail){
    flash.style.opacity = 1;
    setTimeout(()=> { flash.style.opacity = 0; }, 600);
  } else {
    flash.style.opacity = 0;
  }
}

/* confetti: spawn multiple particles */
function spawnConfetti(){
  for(let i=0;i<40;i++){
    confetti.push({
      x: canvas.width * 0.5 + (Math.random()-0.5)*200,
      y: 20 + Math.random()*40,
      vx: (Math.random()-0.5)*3,
      vy: 1 + Math.random()*3,
      size: 4 + Math.random()*6,
      life: 100 + Math.random()*80,
      color: ['#FF3B30','#FF9500','#34C759','#007AFF','#AF52DE'][Math.floor(Math.random()*5)]
    });
  }
}

/* animate confetti */
function drawConfetti(dt){
  confCtx.clearRect(0,0,confCanvas.width,confCanvas.height);
  for(let i=confetti.length-1;i>=0;i--){
    const p = confetti[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.06;
    p.life -= 1;
    confCtx.fillStyle = p.color;
    confCtx.fillRect(p.x, p.y, p.size, p.size*0.6);
    if(p.life <= 0 || p.y > confCanvas.height + 30) confetti.splice(i,1);
  }
}

/* -------------------------
   TRANSITION & END SCREENS
   ------------------------- */
function drawTransition(title, subtitle, btnText){
  centerText.style.display='block';
  centerText.innerText = `${title}\n${subtitle}\n\nPress START to continue`;
  btnStart.style.display = 'inline-block';
}

function drawEndScreen(){
  centerText.style.display='block';
  centerText.innerText = `All games finished!\n\nResults:\nClass1: ${scores[0]} / ${GOAL_PER_GAME}\nClass2: ${scores[1]} / ${GOAL_PER_GAME}\nClass3: ${scores[2]} / ${GOAL_PER_GAME}\n\nPress Restart to play again.`;
  btnStart.style.display='none';
  btnRestart.style.display='inline-block';
  btnPause.style.display='none';
}

/* -------------------------
   UI Buttons
   ------------------------- */
  
btnStart.onclick = async ()=>{
  // first click: load model & webcam (if not loaded)
  if(!model){
    await loadModel();
    await startWebcam();
  }
  // start/continue logic
  if(gameState === 'idle'){
    // initial start -> game1
    gameState = 'game1'; gameIndex = 0;
    roundsPlayed = 0;
    scores = [0,0,0];
    updateSummaries();
    setScore(0);
    setGoal(GOAL_PER_GAME);
    btnStart.style.display='none';
    btnPause.style.display='inline-block';
    btnRestart.style.display='inline-block';
    centerText.style.display='none';
    // ensure ball ready
    resetBall();
  } else if(gameState === 'inter1'){
    gameState = 'game2';
    gameIndex = 1;
    roundsPlayed = 0; setScore(scores[1]); setGoal(GOAL_PER_GAME);
    centerText.style.display='none'; btnStart.style.display='none';
  } else if(gameState === 'inter2'){
    gameState = 'game3';
    gameIndex = 2;
    roundsPlayed = 0; setScore(scores[2]); setGoal(GOAL_PER_GAME);
    centerText.style.display='none'; btnStart.style.display='none';
  }
};
  
btnPause.onclick = ()=>{
  if(gameState !== 'paused'){ gameState = 'paused'; btnPause.innerText='Resume'; setStatus('Paused'); }
  else { // resume last known gameIndex
    if(gameIndex === 0) gameState='game1';
    else if(gameIndex === 1) gameState='game2';
    else if(gameIndex === 2) gameState='game3';
    btnPause.innerText='Pause';
  }
};

btnRestart.onclick = ()=>{
  // reset everything
  scores = [0,0,0]; roundsPlayed=0; updateSummaries(); setScore(0); setGoal(GOAL_PER_GAME);
  gameState = 'idle';
  btnStart.style.display='inline-block';
  btnRestart.style.display='none';
  btnPause.style.display='none';
  centerText.style.display='block';
  centerText.innerText = 'Press START to begin';
  setStatus('Waiting');
  // reset ball and other state
  ball = { x:200, y:-20, r:14, speed:1.2, active:true, waitingContinue:false };
  boxList = [];
  rotateProgress = 0;
};

/* -------------------------
   INITIALIZE & start game loop
   ------------------------- */
(async function initAll(){
  setGoal(GOAL_PER_GAME);
  setStatus('Ready (model not loaded)');
  // Start the game loop immediately
  requestAnimationFrame(gameLoop);
})();
