<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3-Class Rehab Game Suite</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
<style>
  :root{
    --bg: #022F56;
    --card: rgba(255,255,255,0.95);
    --accent: #85C4E4;
  }
  body{
    margin:0;
    height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    font-family:"Poppins",sans-serif;
    background: var(--bg);
  }
  .app {
    width:920px;
    max-width:96vw;
    background: var(--card);
    border-radius:12px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.12);
    padding:18px;
    display:grid;
    grid-template-columns: 440px 1fr;
    gap:12px;
  }

  .left {
    display:flex;
    flex-direction:column;
    align-items:center;
  }

  h1 { color:#8FB3E2; margin:6px 0 14px; font-size:18px; text-align:center; }

  button.primary {
    background:#488DB4; color:#000; border: none; padding:10px 18px; border-radius:8px; cursor:pointer; font-weight:600;
  }

  #gameArea {
    width:420px; height:520px; background:#CCDEE4; border-radius:10px; position:relative; overflow:hidden; display:flex; align-items:center; justify-content:center;
    box-shadow: inset 0 2px 6px rgba(0,0,0,0.04);
  }

  canvas#gameCanvas { background: transparent; display:block; }

  .right {
    padding: 8px;
    display:flex;
    flex-direction:column;
    gap:8px;
  }

  .panel {
    background: white;
    border-radius:8px;
    padding:10px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.06);
  }

  #webcam-container canvas { width:200px; height:200px; border-radius:8px; border:1px solid #ddd; }

  .labels div { margin:6px 0; background:rgba(0,0,0,0.03); padding:8px; border-radius:6px; font-size:14px; }

  #status { font-weight:700; color:#1E2E4F; margin-bottom:6px; }

  #confettiCanvas { position:absolute; left:0; top:0; pointer-events:none; }

  .bigCenter {
    position:absolute; left:0; right:0; top:40%; text-align:center; font-size:22px; color:#1E2E4F; font-weight:700;
    white-space:pre-line;
  }

  .transition {
    display:flex; flex-direction:column; align-items:center; justify-content:center; gap:8px; height:100%;
  }

  .summary-row { display:flex; justify-content:space-between; padding:6px 8px; border-bottom:1px dashed #eee; }
  .small { font-size:13px; color:#666; }

  /* flash overlay for fail */
  #flash {
    position:absolute; inset:0; background:rgba(255,0,0,0.15); pointer-events:none; opacity:0; transition:opacity 300ms ease;
  }

  footer.note { text-align:center; font-size:12px; color:#666; margin-top:8px; }

  /* continue button style overlay */
  #continueBtn {
    position:absolute;
    bottom:28px;
    left:50%;
    transform:translateX(-50%);
    background:#34C759;
    color:#fff;
    border:none;
    padding:10px 16px;
    border-radius:10px;
    cursor:pointer;
    font-weight:700;
    display:none;
    box-shadow: 0 6px 14px rgba(34,139,230,0.14);
  }

  /* small label highlight */
  .detected {
    box-shadow: 0 0 0 3px rgba(34,139,230,0.08) inset;
    border-radius:6px;
  }
</style>
</head>
<body>
  <div class="app">
    <div class="left">
      <h1>Rehabilitation Exercise Tracker — 3 Mini-Games</h1>

      <div id="gameArea" class="panel">
        <canvas id="gameCanvas" width="400" height="480"></canvas>
        <canvas id="confettiCanvas" width="400" height="480"></canvas>
        <div id="flash"></div>
        <div class="bigCenter" id="centerText">Press START to begin</div>
        <button id="continueBtn">Continue ▶</button>
      </div>

      <div style="margin-top:10px; display:flex; gap:8px;">
        <button class="primary" id="btnStart">Start</button>
        <button id="btnPause" class="primary" style="display:none">Pause</button>
        <button id="btnRestart" class="primary" style="display:none">Restart</button>
      </div>
      <div style="margin-top:8px; display:flex; gap:12px;">
        <div id="scorePanel" class="panel" style="min-width:150px;">
          <div><strong>Game</strong></div>
          <div id="gameName">—</div>
          <div style="margin-top:6px"><strong>Score</strong> <span id="score">0</span> / <span id="goal">7</span></div>
        </div>

        <div id="progressPanel" class="panel" style="flex:1;">
          <div id="status">Status: Waiting</div>
          <div class="small">Last result: <span id="lastResult">—</span></div>
        </div>
      </div>

      <div style="margin-top:8px; width:100%;">
        <footer class="note">Uses your webcam. Allow camera access. Be seated comfortably and keep hand in frame.</footer>
      </div>
    </div>

    <div class="right">
      <div class="panel">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <strong>Webcam</strong>
          <span class="small">Model predictions</span>
        </div>
        <div id="webcam-container" style="margin-top:8px;"></div>
      </div>

      <div class="panel labels">
        <div id="class0">Class 1: 0.00%</div>
        <div id="class1">Class 2: 0.00%</div>
        <div id="class2">Class 3: 0.00%</div>
      </div>

      <div class="panel">
        <strong>Summary</strong>
        <div class="summary-row"><div>Ball Catch (Class1)</div><div id="sum1">0 / 7</div></div>
        <div class="summary-row"><div>Wrist Move (Class2)</div><div id="sum2">0 / 7</div></div>
        <div class="summary-row"><div>Fist Rotate (Class3)</div><div id="sum3">0 / 7</div></div>
      </div>

      <div class="panel" style="text-align:center">
        <strong>Controls & Tips</strong>
        <div class="small" style="margin-top:6px">
          - Keep gestures clear.<br>
          - open/close palm for game 1<br>
          - move wrist left to right in game 2<br>
          - rotate fist in game 3<br>
          - After a successful catch press Continue to drop next ball.
        </div>
      </div>
    </div>
  </div>

<script>
/* -------------------------
   CONFIG (tweak here)
   ------------------------- */
const MODEL_URL = "https://teachablemachine.withgoogle.com/models/ZwgUkHwE_/"; // keep your model base URL here
const UPDATE_INTERVAL = 600; // ms  — prediction frequency
const CLASS_INDEX = { c1: 0, c2: 1, c3: 2 }; // if your model classes order differs, change indices
const THRESH = { c1: 0.6, c2: 0.6, c3: 0.65 }; // detection thresholds
const LATCH_MS = 1500; // how long to remember a detected gesture (ms)
const GOAL_PER_GAME = 7; // number of successful rounds per game

/* -------------------------
   State & game variables
   ------------------------- */
let model, webcam, labelContainer, maxPredictions;
let lastPredTime = 0;
let lastPredictions = [0,0,0];

// gesture latch timestamps (when model last saw the gesture)
let gestureCatch1 = 0;
let gestureCatch2 = 0;
let gestureCatch3 = 0;
// boolean flags for active gestures (true while considered active)
let gestureActive1 = false;
let gestureActive2 = false;
let gestureActive3 = false;

let canvas = document.getElementById('gameCanvas');
let ctx = canvas.getContext('2d');
let confCanvas = document.getElementById('confettiCanvas');
let confCtx = confCanvas.getContext('2d');
let flash = document.getElementById('flash');
let centerText = document.getElementById('centerText');
let btnStart = document.getElementById('btnStart');
let btnPause = document.getElementById('btnPause');
let btnRestart = document.getElementById('btnRestart');
let continueBtn = document.getElementById('continueBtn');

let gameState = 'idle'; // idle, game1, inter1, game2, inter2, game3, end, paused
let gameIndex = 0; // 0..2
let scores = [0,0,0];
let roundsPlayed = 0;

/* --- Game1 (ball catch) --- */
let ball = { x:200, y:-20, r:14, speed:1.2, active:true, waitingContinue:false };

/* --- Game2 (wrist move paddle) --- */
let paddle = { x:200, w:120 }; // paddle responds to class2 detection
let boxList = []; // falling boxes to catch
let boxSpeed = 1.0;

/* --- Game3 (fist rotation) --- */
let rotateProgress = 0; // 0..360 degrees; user must sustain class3 to fill
let rotateTarget = 360;

/* --- Confetti particles --- */
let confetti = [];

/* --- Audio (WebAudio) --- */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function beep(freq=440, time=0.12, type='sine'){
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.2, audioCtx.currentTime + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + time);
  o.stop(audioCtx.currentTime + time + 0.02);
}
function playWin(){
  beep(880,0.12,'sine'); setTimeout(()=>beep(660,0.12,'sine'),120);
}
function playFail(){ beep(180,0.25,'sawtooth'); }

/* -------------------------
   UTIL / UI updates
   ------------------------- */
function setStatus(text){ document.getElementById('status').innerText = 'Status: ' + text; }
function setGameName(name){ document.getElementById('gameName').innerText = name; }
function setScore(n){ document.getElementById('score').innerText = n; }
function setGoal(n){ document.getElementById('goal').innerText = n; }
function setLastResult(text){ document.getElementById('lastResult').innerText = text; }
function updateSummaries(){
  document.getElementById('sum1').innerText = `${scores[0]} / ${GOAL_PER_GAME}`;
  document.getElementById('sum2').innerText = `${scores[1]} / ${GOAL_PER_GAME}`;
  document.getElementById('sum3').innerText = `${scores[2]} / ${GOAL_PER_GAME}`;
}

/* -------------------------
   MODEL + WEBCAM LOADING
   ------------------------- */
async function loadModel(){
  setStatus('Loading model...');
  const modelURL = MODEL_URL + 'model.json';
  const metadataURL = MODEL_URL + 'metadata.json';
  model = await tmImage.load(modelURL, metadataURL);
  maxPredictions = model.getTotalClasses();
  labelContainer = {
    0: document.getElementById('class0'),
    1: document.getElementById('class1'),
    2: document.getElementById('class2')
  };
  setStatus('Model loaded. Click Start.');
}

async function startWebcam(){
  const flip = true;
  webcam = new tmImage.Webcam(320, 320, flip);
  await webcam.setup();
  await webcam.play();
  const container = document.getElementById('webcam-container');
  container.innerHTML = '';
  container.appendChild(webcam.canvas);
}

/* -------------------------
   PREDICTION LOOP
   ------------------------- */
async function predictionTick(timestamp){
  if(!webcam || !model) return;
  webcam.update();
  const now = performance.now();
  if(now - lastPredTime >= UPDATE_INTERVAL){
    lastPredTime = now;
    const preds = await model.predict(webcam.canvas);
    // map probabilities into lastPredictions and UI
    for(let i=0;i<Math.min(3,preds.length);i++){
      lastPredictions[i] = preds[i].probability;
      labelContainer[i].innerText = `${preds[i].className}: ${(preds[i].probability*100).toFixed(2)}%`;
    }

    // Latch gestures: store timestamps when above threshold and set active flags
    if(lastPredictions[CLASS_INDEX.c1] >= THRESH.c1) {
      gestureCatch1 = now;
      gestureActive1 = true;
    } else if (now - gestureCatch1 > LATCH_MS) {
      gestureActive1 = false;
    }

    if(lastPredictions[CLASS_INDEX.c2] >= THRESH.c2) {
      gestureCatch2 = now;
      gestureActive2 = true;
    } else if (now - gestureCatch2 > LATCH_MS) {
      gestureActive2 = false;
    }

    if(lastPredictions[CLASS_INDEX.c3] >= THRESH.c3) {
      gestureCatch3 = now;
      gestureActive3 = true;
    } else if (now - gestureCatch3 > LATCH_MS) {
      gestureActive3 = false;
    }

    // add simple UI highlight when detection is active
    updateLabelHighlights();
  }
}

function updateLabelHighlights(){
  for(let i=0;i<3;i++){
    const el = labelContainer[i];
    if(!el) continue;
    const prob = lastPredictions[i] || 0;
    const thr = (i===CLASS_INDEX.c1?THRESH.c1:(i===CLASS_INDEX.c2?THRESH.c2:THRESH.c3));
    if(prob >= thr){
      el.classList.add('detected');
    } else {
      el.classList.remove('detected');
    }
  }
}

/* -------------------------
   GAME DRAW / LOGIC LOOP
   ------------------------- */
let lastFrame = 0;
function gameLoop(ts){
  const now = ts || performance.now();
  const dt = Math.min(40, now - lastFrame);
  lastFrame = now;

  // run prediction tick occasionally
  predictionTick();

  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // routing by state
  if(gameState === 'idle'){
    drawCenterText('Press START to begin', '#1E2E4F');
  } else if(gameState === 'game1'){
    runGame1(dt);
  } else if(gameState === 'inter1'){
    drawTransition('Class 1 finished', `Score: ${scores[0]} / ${GOAL_PER_GAME}`, 'Play Next');
  } else if(gameState === 'game2'){
    runGame2(dt);
  } else if(gameState === 'inter2'){
    drawTransition('Class 2 finished', `Score: ${scores[1]} / ${GOAL_PER_GAME}`, 'Play Next');
  } else if(gameState === 'game3'){
    runGame3(dt);
  } else if(gameState === 'end'){
    drawEndScreen();
  } else if(gameState === 'paused'){
    drawCenterText('Paused', '#1E2E4F');
  }

  // confetti draw
  drawConfetti(dt);

  requestAnimationFrame(gameLoop);
}

/* -------------------------
   DRAW HELPERS
   ------------------------- */
function drawCenterText(text, color='#1E2E4F'){
  centerText.style.display='block';
  centerText.style.color = color;
  centerText.innerText = text;
}
function hideCenterText(){ centerText.style.display='none'; }

/* -------------------------
   GAME1: Ball Catch
   ------------------------- */
function runGame1(dt){
  hideCenterText();
  continueBtn.style.display = ball.waitingContinue ? 'inline-block' : 'none';
  setGameName('Ball Catch — Class 1 (open/close palm)');
  setStatus('Perform Class 1 gesture to catch when ball near bottom');
  btnPause.style.display='inline-block';
  btnRestart.style.display='inline-block';

  // draw ground indicator (catch zone)
  const catchY = canvas.height - 60;
  ctx.fillStyle = 'rgba(50,200,100,0.06)';
  ctx.fillRect(0, catchY, canvas.width, 60);

  // draw ball
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
  ctx.fillStyle = '#E43D40';
  ctx.fill();
  ctx.closePath();

  // move ball only if active and not waiting for continue
  if(ball.active && !ball.waitingContinue){
    ball.y += ball.speed;
  }

  // check catch condition using gestureActive1 (robust)
  const class1Prob = lastPredictions[CLASS_INDEX.c1] || 0;
  if(ball.active && !ball.waitingContinue){
    if(ball.y >= catchY && ball.y <= canvas.height - 10){
      // show prompt
      ctx.fillStyle = '#000';
      ctx.font = '14px Poppins';
      ctx.fillText('Perform Class1 to catch', 12, catchY - 10);

      if(gestureActive1){
        // Caught: disable immediate re-fire by clearing active flag & timestamp
        ball.active = false;
        ball.waitingContinue = true; // pause until Continue clicked
        onWin(0);
        gestureActive1 = false;
        gestureCatch1 = 0;
        continueBtn.style.display = 'inline-block';
      }
    }

    // if ball goes beyond bottom
    if(ball.y > canvas.height + 20){
      ball.active = false;
      onFail(0);
      setTimeout(()=> resetBall(), 450);
    }
  }

  // HUD
  ctx.fillStyle = '#000';
  ctx.font = '14px Poppins';
  ctx.fillText(`Ball ${roundsPlayed+1} / ${GOAL_PER_GAME}`, 12, 20);
  ctx.fillText(`Class1: ${(class1Prob*100).toFixed(0)}%`, 12, 40);
}

/* reset ball */
function resetBall(){
  ball.x = 30 + Math.random()*(canvas.width-60);
  ball.y = -20;
  ball.r = 16;
  ball.speed = 1.1; // slow
  ball.active = true;
  ball.waitingContinue = false;
  roundsPlayed++;
  // hide continue
  continueBtn.style.display = 'none';

  // if finished rounds
  if(roundsPlayed >= GOAL_PER_GAME){
      gameState = 'inter1'; // immediately transition
      setLastResult(`Score: ${scores[0]} / ${GOAL_PER_GAME}`);
      setStatus('Finished Class 1');
      setScore(scores[0]);
      updateSummaries();
      roundsPlayed = 0;
      continueBtn.style.display = 'none';
    }, 500);
  }
}

/* Continue button behaviour (for Game1) */
continueBtn.onclick = () => {
  if(gameState !== 'game1') return;
  if(ball.waitingContinue){
    resetBall();
  }
};

/* -------------------------
   GAME2: Wrist Move (Class2)
   ------------------------- */
function spawnBox(){
boxList.push({ x: 20 + Math.random() * (canvas.width - 40), y: -30, w: 28, h: 28, caught:false });
}
function runGame2(dt){
  hideCenterText();
  setGameName('Wrist Move — Class 2');
  setStatus('Perform Class 2 (move wrist) to shift paddle and catch boxes');
  btnPause.style.display='inline-block';
  btnRestart.style.display='inline-block';

  // draw paddle
  const pY = canvas.height - 40;
  ctx.fillStyle = '#2B63A6';
  ctx.fillRect(paddle.x - paddle.w/2, pY, paddle.w, 12);
  // draw boxes
  for(let i=0;i<boxList.length;i++){
    const b = boxList[i];
    ctx.fillStyle = '#F5A623';
    ctx.fillRect(b.x, b.y, b.w, b.h);
    b.y += boxSpeed; // boxes now fall down
  }

  if(boxList.length < 3 && Math.random() < 0.015) spawnBox();

  // control paddle using gestureActive2
  const class2Prob = lastPredictions[CLASS_INDEX.c2] || 0;
  if(gestureActive2) {
    paddle.x += 4 * (0.6 + class2Prob);
  } else {
    paddle.x -= 1.5;
  }
  // clamp
  if(paddle.x < paddle.w/2) paddle.x = paddle.w/2;
  if(paddle.x > canvas.width - paddle.w/2) paddle.x = canvas.width - paddle.w/2;

  // collisions
  for(let i = boxList.length-1; i>=0; i--){
    const b = boxList[i];
    if(b.x + b.w < 0){
      boxList.splice(i,1);
      roundsPlayed++;
      onFail(1);
      continue;
    }
    if(b.y + b.h >= pY && b.y <= pY + 12 && b.x < paddle.x + paddle.w/2 && b.x + b.w > paddle.x - paddle.w/2){
      boxList.splice(i,1);
      roundsPlayed++;
      onWin(1);
      continue;
    }
  }

  // HUD
  ctx.fillStyle = '#000';
  ctx.font = '14px Poppins';
  ctx.fillText(`Boxes caught: ${scores[1]} / ${GOAL_PER_GAME}`, 12, 20);
  ctx.fillText(`Class2: ${(class2Prob*100).toFixed(0)}%`, 12, 40);

  // end condition
  if(roundsPlayed >= GOAL_PER_GAME){
    setTimeout(()=> {
      gameState = 'inter2';
      setLastResult(`Score: ${scores[1]} / ${GOAL_PER_GAME}`);
      setStatus('Finished Class 2');
      setScore(scores[1]);
      updateSummaries();
      roundsPlayed = 0;
      boxList = [];
    }, 600);
  }
}

/* -------------------------
   GAME3: Fist Rotation (Class3)
   ------------------------- */
function runGame3(dt){
  hideCenterText();
  setGameName('Fist Rotate — Class 3');
  setStatus('Perform Class 3 (fist rotate) and hold to fill the meter');
  btnPause.style.display='inline-block';
  btnRestart.style.display='inline-block';

  const centerX = canvas.width/2;
  const centerY = canvas.height/2;
  ctx.beginPath();
  ctx.arc(centerX, centerY - 20, 70, 0, Math.PI*2);
  ctx.fillStyle = '#eef6ff';
  ctx.fill(); ctx.closePath();

  const class3Prob = lastPredictions[CLASS_INDEX.c3] || 0;
  ctx.fillStyle = '#222';
  ctx.font = '14px Poppins';
  ctx.fillText(`Class3: ${(class3Prob*100).toFixed(0)}%`, 12, 20);

  if(gestureActive3){
    rotateProgress += 2 * (0.5 + class3Prob*1.0);
  } else {
    rotateProgress -= 1.2;
  }
  if(rotateProgress < 0) rotateProgress = 0;
  if(rotateProgress > rotateTarget) rotateProgress = rotateTarget;

  const pct = rotateProgress / rotateTarget;
  ctx.beginPath();
  ctx.arc(centerX, centerY - 20, 70, -Math.PI/2, -Math.PI/2 + pct * Math.PI*2);
  ctx.strokeStyle = '#2B63A6';
  ctx.lineWidth = 12;
  ctx.stroke(); ctx.closePath();

  ctx.fillStyle = '#1E2E4F';
  ctx.font = '18px Poppins';
  ctx.textAlign='center';
  ctx.fillText(Math.floor(pct*100) + '%', centerX, centerY - 18);

  if(rotateProgress >= rotateTarget){
    rotateProgress = 0;
    roundsPlayed++;
    // prevent immediate re-fire
    gestureActive3 = false;
    gestureCatch3 = 0;
    onWin(2);
  }

  ctx.textAlign='left';
  ctx.fillStyle='#000';
  ctx.font='14px Poppins';
  ctx.fillText(`Round ${roundsPlayed+1} / ${GOAL_PER_GAME}`, 12, canvas.height - 20);

  if(roundsPlayed >= GOAL_PER_GAME){
    setTimeout(()=> {
      gameState = 'end';
      setLastResult(`Score: ${scores[2]} / ${GOAL_PER_GAME}`);
      setStatus('Finished Class 3');
      setScore(scores[2]);
      updateSummaries();
      roundsPlayed = 0;
    }, 600);
  }
}

/* -------------------------
   WIN / FAIL HANDLERS
   ------------------------- */
function onWin(gameIdx){
  scores[gameIdx] = Math.min(GOAL_PER_GAME, scores[gameIdx] + 1);
  setScore(scores[gameIdx]);
  setLastResult('Win!');
  updateSummaries();
  playWin();
  spawnConfetti();
  showFlash(false);
  centerText.style.display='block';
  centerText.innerText = 'Great! ✔';
  setTimeout(()=> centerText.style.display='none', 800);
}

function onFail(gameIdx){
  setLastResult('Miss');
  setStatus('Try again');
  playFail();
  showFlash(true);
  centerText.style.display='block';
  centerText.innerText = 'Missed ❌';
  setTimeout(()=> {
    centerText.style.display='none';
    showFlash(false);
  }, 900);
}

/* -------------------------
   Flash & Confetti
   ------------------------- */
function showFlash(isFail){
  if(isFail){
    flash.style.opacity = 1;
    setTimeout(()=> { flash.style.opacity = 0; }, 600);
  } else {
    flash.style.opacity = 0;
  }
}

function spawnConfetti(){
  for(let i=0;i<40;i++){
    confetti.push({
      x: canvas.width * 0.5 + (Math.random()-0.5)*200,
      y: 20 + Math.random()*40,
      vx: (Math.random()-0.5)*3,
      vy: 1 + Math.random()*3,
      size: 4 + Math.random()*6,
      life: 100 + Math.random()*80,
      color: ['#FF3B30','#FF9500','#34C759','#007AFF','#AF52DE'][Math.floor(Math.random()*5)]
    });
  }
}

function drawConfetti(dt){
  confCtx.clearRect(0,0,confCanvas.width,confCanvas.height);
  for(let i=confetti.length-1;i>=0;i--){
    const p = confetti[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.06;
    p.life -= 1;
    confCtx.fillStyle = p.color;
    confCtx.fillRect(p.x, p.y, p.size, p.size*0.6);
    if(p.life <= 0 || p.y > confCanvas.height + 30) confetti.splice(i,1);
  }
}

/* -------------------------
   TRANSITION & END SCREENS
   ------------------------- */
function drawTransition(title, subtitle, btnText){
  centerText.style.display='block';
  centerText.innerText = `${title}\n${subtitle}\n\nPress START to continue`;
  btnStart.style.display = 'inline-block';
}

function drawEndScreen(){
  centerText.style.display='block';
  centerText.innerText = `All games finished!\n\nResults:\nClass1: ${scores[0]} / ${GOAL_PER_GAME}\nClass2: ${scores[1]} / ${GOAL_PER_GAME}\nClass3: ${scores[2]} / ${GOAL_PER_GAME}\n\nPress Restart to play again.`;
  btnStart.style.display='none';
  btnRestart.style.display='inline-block';
  btnPause.style.display='none';
}

/* -------------------------
   UI Buttons
   ------------------------- */
btnStart.onclick = async () => {
  try {
    btnStart.disabled = true;
    setStatus("Loading model...");

    // 🔹 Load Teachable Machine model only once
    if (!model) {
      isModelLoading = true;
      const modelURL = "https://teachablemachine.withgoogle.com/models/ZwgUkHwE_/";      
      const metadataURL = "https://teachablemachine.withgoogle.com/models/ZwgUkHwE_/";
      model = await tmImage.load(modelURL, metadataURL);
      maxPredictions = model.getTotalClasses();
      console.log("Model loaded successfully");
      isModelLoading = false;
    }

    // 🔹 Setup webcam
    if (!webcam) {
      webcam = new tmImage.Webcam(200, 200, true); // width, height, flip
      await webcam.setup();
      await webcam.play();
      window.requestAnimationFrame(loop);
      document.getElementById("webcam-container").appendChild(webcam.canvas);
      console.log("Webcam started");
    }

    // 🔹 Now handle class switching
    if (gameState === "idle") {
      // Start Class 1
      gameIndex = 0;
      gameState = "game1";
      scores[0] = 0;
      setScore(0);
      setGoal(GOAL_PER_GAME);
      setStatus("Class 1: Catch the Ball");
      hideCenterText();
      continueBtn.style.display = "none";
      console.log("Starting Class 1");
      return;
    }

    if (gameState === "inter1") {
      // Start Class 2
      gameIndex = 1;
      gameState = "game2";
      scores[1] = 0;
      setScore(0);
      setGoal(GOAL_PER_GAME);
      setStatus("Class 2: Catch the Boxes");
      hideCenterText();
      continueBtn.style.display = "none";
      boxList = [];
      console.log("Starting Class 2");
      return;
    }

    if (gameState === "inter2") {
      // Start Class 3
      gameIndex = 2;
      gameState = "game3";
      scores[2] = 0;
      setScore(0);
      setGoal(GOAL_PER_GAME);
      setStatus("Class 3: Final Challenge");
      hideCenterText();
      continueBtn.style.display = "none";
      console.log("Starting Class 3");
      return;
    }
  } catch (err) {
    console.error("Error starting model or game:", err);
    setStatus("Error: check console for details");
  } finally {
    btnStart.disabled = false;
  }
};

  
btnPause.onclick = ()=>{
  if(gameState !== 'paused'){ gameState = 'paused'; btnPause.innerText='Resume'; setStatus('Paused'); }
  else {
    if(gameIndex === 0) gameState='game1';
    else if(gameIndex === 1) gameState='game2';
    else if(gameIndex === 2) gameState='game3';
    btnPause.innerText='Pause';
  }
};

btnRestart.onclick = ()=>{
  scores = [0,0,0]; roundsPlayed=0; updateSummaries(); setScore(0); setGoal(GOAL_PER_GAME);
  gameState = 'idle';
  btnStart.style.display='inline-block';
  btnRestart.style.display='none';
  btnPause.style.display='none';
  centerText.style.display='block';
  centerText.innerText = 'Press START to begin';
  setStatus('Waiting');
  ball = { x:200, y:-20, r:14, speed:1.2, active:true, waitingContinue:false };
  boxList = [];
  rotateProgress = 0;
};

/* -------------------------
   INITIALIZE & start game loop
   ------------------------- */
(async function initAll(){
  setGoal(GOAL_PER_GAME);
  setStatus('Ready (model not loaded)');
  requestAnimationFrame(gameLoop);
})();
</script>
</body>
</html>

